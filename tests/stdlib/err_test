run {
  arr.int a1 = {0, 45, -45}
  set s1 = set(a1)
}
===== [3:12] index out of range
run {
  set s1
  UnSet(s1, 100000001)
}
===== [3:3] index out of range
run str {
  set s &= {7, 5, `8`, 1}
  return str(s)
}
===== [2:19] wrong type, expecting int type
run {
  set s1 &= set(`01010ar`)
}
===== [2:13] invalid value of parameter(s)
run {
  set s1
  s1[200000000] = true
}
===== [3:6] index out of range
run str {
    CtxSet(`a`, `#b#`)
    CtxSet(`b`, `#c#`)
    CtxSet(`c`, `#a#`)
    return Ctx(`#c#`)
}
===== [5:12] c key refers to itself
run str {
  return CtxSet(`This is a string very long string very very long string key 
  This is a string very long string very very long string key `, 10)
}
===== [2:10] key length is longer than 64 characters
run arr.arr.str {
  return FindRegExp(`This is a string`, `q)`)
}
===== [2:10] error parsing regexp: unexpected ): `q)`
run str {
  return ReplaceRegExp(`This is a string`, `qq(.`, `OK`)
}
===== [2:10] error parsing regexp: missing closing ): `qq(.`
run bool {
  return Match(`OK`, `qq\o`)
}
===== [2:10] error parsing regexp: invalid escape sequence: `\o`
run {
  if true {
      error(77, `1. %s - %d`, `тест`, 70+7)
  }
}
===== [3:7] 1. тест - 77
func myerr(int code) {
  error(code, `My error text`)
}
run {
  myerr(1001)
}
===== [2:3] My error text
run {
  str s
  s = Substr(`test`, 6, -4)
}
===== [3:7] invalid value of parameter(s)
run {
  str s
  s = Substr(`ooops`, 3, -6)
}
===== [3:7] invalid value of parameter(s)
run {
  str s = Substr(`ooops`, 4, 5)
}
===== [2:11] invalid value of parameter(s)
run {
  arr.map a
  Sort(a)
}
===== [3:3] function Sort(arr.map.str) has not been found